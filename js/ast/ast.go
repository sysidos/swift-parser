// generated by Textmapper; DO NOT EDIT

package ast

import (
	"swift-grammer/js"
	"swift-grammer/js/selector"
)

// Interfaces.

type JsNode interface {
	JsNode() *Node
}

type Token struct {
	*Node
}

type NilNode struct{}

var nilInstance = &NilNode{}

// All types implement JsNode.
func (n Abstract) JsNode() *Node                     { return n.Node }
func (n AccessibilityModifier) JsNode() *Node        { return n.Node }
func (n AdditiveExpression) JsNode() *Node           { return n.Node }
func (n Arguments) JsNode() *Node                    { return n.Node }
func (n ArrayLiteral) JsNode() *Node                 { return n.Node }
func (n ArrayPattern) JsNode() *Node                 { return n.Node }
func (n ArrayType) JsNode() *Node                    { return n.Node }
func (n ArrowFunction) JsNode() *Node                { return n.Node }
func (n AssignmentExpression) JsNode() *Node         { return n.Node }
func (n AssignmentOperator) JsNode() *Node           { return n.Node }
func (n AsyncArrowFunction) JsNode() *Node           { return n.Node }
func (n AsyncFunction) JsNode() *Node                { return n.Node }
func (n AsyncFunctionExpression) JsNode() *Node      { return n.Node }
func (n AsyncMethod) JsNode() *Node                  { return n.Node }
func (n AwaitExpression) JsNode() *Node              { return n.Node }
func (n BindingIdentifier) JsNode() *Node            { return n.Node }
func (n BindingRestElement) JsNode() *Node           { return n.Node }
func (n BitwiseANDExpression) JsNode() *Node         { return n.Node }
func (n BitwiseORExpression) JsNode() *Node          { return n.Node }
func (n BitwiseXORExpression) JsNode() *Node         { return n.Node }
func (n Block) JsNode() *Node                        { return n.Node }
func (n Body) JsNode() *Node                         { return n.Node }
func (n BreakStatement) JsNode() *Node               { return n.Node }
func (n CallExpression) JsNode() *Node               { return n.Node }
func (n CallSignature) JsNode() *Node                { return n.Node }
func (n Case) JsNode() *Node                         { return n.Node }
func (n Catch) JsNode() *Node                        { return n.Node }
func (n Class) JsNode() *Node                        { return n.Node }
func (n ClassBody) JsNode() *Node                    { return n.Node }
func (n ClassExpr) JsNode() *Node                    { return n.Node }
func (n CoalesceExpression) JsNode() *Node           { return n.Node }
func (n CommaExpression) JsNode() *Node              { return n.Node }
func (n ComputedPropertyName) JsNode() *Node         { return n.Node }
func (n ConciseBody) JsNode() *Node                  { return n.Node }
func (n ConditionalExpression) JsNode() *Node        { return n.Node }
func (n ConstructSignature) JsNode() *Node           { return n.Node }
func (n ConstructorType) JsNode() *Node              { return n.Node }
func (n ContinueStatement) JsNode() *Node            { return n.Node }
func (n DebuggerStatement) JsNode() *Node            { return n.Node }
func (n DecoratorCall) JsNode() *Node                { return n.Node }
func (n DecoratorExpr) JsNode() *Node                { return n.Node }
func (n Default) JsNode() *Node                      { return n.Node }
func (n DefaultParameter) JsNode() *Node             { return n.Node }
func (n DoWhileStatement) JsNode() *Node             { return n.Node }
func (n ElementBinding) JsNode() *Node               { return n.Node }
func (n EmptyDecl) JsNode() *Node                    { return n.Node }
func (n EmptyStatement) JsNode() *Node               { return n.Node }
func (n EqualityExpression) JsNode() *Node           { return n.Node }
func (n ExponentiationExpression) JsNode() *Node     { return n.Node }
func (n ExportClause) JsNode() *Node                 { return n.Node }
func (n ExportDeclaration) JsNode() *Node            { return n.Node }
func (n ExportDefault) JsNode() *Node                { return n.Node }
func (n ExportSpecifier) JsNode() *Node              { return n.Node }
func (n ExpressionStatement) JsNode() *Node          { return n.Node }
func (n Extends) JsNode() *Node                      { return n.Node }
func (n Finally) JsNode() *Node                      { return n.Node }
func (n ForBinding) JsNode() *Node                   { return n.Node }
func (n ForCondition) JsNode() *Node                 { return n.Node }
func (n ForFinalExpression) JsNode() *Node           { return n.Node }
func (n ForInStatement) JsNode() *Node               { return n.Node }
func (n ForInStatementWithVar) JsNode() *Node        { return n.Node }
func (n ForOfStatement) JsNode() *Node               { return n.Node }
func (n ForOfStatementWithVar) JsNode() *Node        { return n.Node }
func (n ForStatement) JsNode() *Node                 { return n.Node }
func (n ForStatementWithVar) JsNode() *Node          { return n.Node }
func (n Function) JsNode() *Node                     { return n.Node }
func (n FunctionExpression) JsNode() *Node           { return n.Node }
func (n FunctionType) JsNode() *Node                 { return n.Node }
func (n Generator) JsNode() *Node                    { return n.Node }
func (n GeneratorExpression) JsNode() *Node          { return n.Node }
func (n GeneratorMethod) JsNode() *Node              { return n.Node }
func (n Getter) JsNode() *Node                       { return n.Node }
func (n IdentifierReference) JsNode() *Node          { return n.Node }
func (n IfStatement) JsNode() *Node                  { return n.Node }
func (n ImportDeclaration) JsNode() *Node            { return n.Node }
func (n ImportSpecifier) JsNode() *Node              { return n.Node }
func (n ImportType) JsNode() *Node                   { return n.Node }
func (n IndexAccess) JsNode() *Node                  { return n.Node }
func (n IndexSignature) JsNode() *Node               { return n.Node }
func (n IndexedAccessType) JsNode() *Node            { return n.Node }
func (n Initializer) JsNode() *Node                  { return n.Node }
func (n IntersectionType) JsNode() *Node             { return n.Node }
func (n JSXAttributeName) JsNode() *Node             { return n.Node }
func (n JSXClosingElement) JsNode() *Node            { return n.Node }
func (n JSXElement) JsNode() *Node                   { return n.Node }
func (n JSXElementName) JsNode() *Node               { return n.Node }
func (n JSXExpression) JsNode() *Node                { return n.Node }
func (n JSXLiteral) JsNode() *Node                   { return n.Node }
func (n JSXNormalAttribute) JsNode() *Node           { return n.Node }
func (n JSXOpeningElement) JsNode() *Node            { return n.Node }
func (n JSXSelfClosingElement) JsNode() *Node        { return n.Node }
func (n JSXSpreadAttribute) JsNode() *Node           { return n.Node }
func (n JSXSpreadExpression) JsNode() *Node          { return n.Node }
func (n JSXText) JsNode() *Node                      { return n.Node }
func (n KeyOfType) JsNode() *Node                    { return n.Node }
func (n LabelIdentifier) JsNode() *Node              { return n.Node }
func (n LabelledStatement) JsNode() *Node            { return n.Node }
func (n LexicalBinding) JsNode() *Node               { return n.Node }
func (n LexicalDeclaration) JsNode() *Node           { return n.Node }
func (n Literal) JsNode() *Node                      { return n.Node }
func (n LiteralPropertyName) JsNode() *Node          { return n.Node }
func (n LiteralType) JsNode() *Node                  { return n.Node }
func (n LogicalANDExpression) JsNode() *Node         { return n.Node }
func (n LogicalORExpression) JsNode() *Node          { return n.Node }
func (n MappedType) JsNode() *Node                   { return n.Node }
func (n MemberMethod) JsNode() *Node                 { return n.Node }
func (n MemberVar) JsNode() *Node                    { return n.Node }
func (n Method) JsNode() *Node                       { return n.Node }
func (n MethodSignature) JsNode() *Node              { return n.Node }
func (n Module) JsNode() *Node                       { return n.Node }
func (n ModuleSpecifier) JsNode() *Node              { return n.Node }
func (n MultiplicativeExpression) JsNode() *Node     { return n.Node }
func (n NameSpaceImport) JsNode() *Node              { return n.Node }
func (n NamedImports) JsNode() *Node                 { return n.Node }
func (n NewExpression) JsNode() *Node                { return n.Node }
func (n NewTarget) JsNode() *Node                    { return n.Node }
func (n NonNullableType) JsNode() *Node              { return n.Node }
func (n NullableType) JsNode() *Node                 { return n.Node }
func (n ObjectLiteral) JsNode() *Node                { return n.Node }
func (n ObjectMethod) JsNode() *Node                 { return n.Node }
func (n ObjectPattern) JsNode() *Node                { return n.Node }
func (n ObjectType) JsNode() *Node                   { return n.Node }
func (n OptionalCallExpression) JsNode() *Node       { return n.Node }
func (n OptionalIndexAccess) JsNode() *Node          { return n.Node }
func (n OptionalPropertyAccess) JsNode() *Node       { return n.Node }
func (n OptionalTaggedTemplate) JsNode() *Node       { return n.Node }
func (n Parameters) JsNode() *Node                   { return n.Node }
func (n Parenthesized) JsNode() *Node                { return n.Node }
func (n ParenthesizedType) JsNode() *Node            { return n.Node }
func (n PostDec) JsNode() *Node                      { return n.Node }
func (n PostInc) JsNode() *Node                      { return n.Node }
func (n PreDec) JsNode() *Node                       { return n.Node }
func (n PreInc) JsNode() *Node                       { return n.Node }
func (n PredefinedType) JsNode() *Node               { return n.Node }
func (n Property) JsNode() *Node                     { return n.Node }
func (n PropertyAccess) JsNode() *Node               { return n.Node }
func (n PropertyBinding) JsNode() *Node              { return n.Node }
func (n PropertySignature) JsNode() *Node            { return n.Node }
func (n Readonly) JsNode() *Node                     { return n.Node }
func (n ReadonlyType) JsNode() *Node                 { return n.Node }
func (n Regexp) JsNode() *Node                       { return n.Node }
func (n RelationalExpression) JsNode() *Node         { return n.Node }
func (n RestParameter) JsNode() *Node                { return n.Node }
func (n RestType) JsNode() *Node                     { return n.Node }
func (n ReturnStatement) JsNode() *Node              { return n.Node }
func (n Setter) JsNode() *Node                       { return n.Node }
func (n ShiftExpression) JsNode() *Node              { return n.Node }
func (n ShorthandProperty) JsNode() *Node            { return n.Node }
func (n SingleNameBinding) JsNode() *Node            { return n.Node }
func (n SpreadElement) JsNode() *Node                { return n.Node }
func (n SpreadProperty) JsNode() *Node               { return n.Node }
func (n Static) JsNode() *Node                       { return n.Node }
func (n SuperExpression) JsNode() *Node              { return n.Node }
func (n SwitchStatement) JsNode() *Node              { return n.Node }
func (n SyntaxProblem) JsNode() *Node                { return n.Node }
func (n TaggedTemplate) JsNode() *Node               { return n.Node }
func (n TemplateLiteral) JsNode() *Node              { return n.Node }
func (n This) JsNode() *Node                         { return n.Node }
func (n ThisType) JsNode() *Node                     { return n.Node }
func (n ThrowStatement) JsNode() *Node               { return n.Node }
func (n TryStatement) JsNode() *Node                 { return n.Node }
func (n TsAmbientBinding) JsNode() *Node             { return n.Node }
func (n TsAmbientClass) JsNode() *Node               { return n.Node }
func (n TsAmbientClassBody) JsNode() *Node           { return n.Node }
func (n TsAmbientEnum) JsNode() *Node                { return n.Node }
func (n TsAmbientFunction) JsNode() *Node            { return n.Node }
func (n TsAmbientFunctionMember) JsNode() *Node      { return n.Node }
func (n TsAmbientImportAlias) JsNode() *Node         { return n.Node }
func (n TsAmbientIndexMember) JsNode() *Node         { return n.Node }
func (n TsAmbientInterface) JsNode() *Node           { return n.Node }
func (n TsAmbientModule) JsNode() *Node              { return n.Node }
func (n TsAmbientNamespace) JsNode() *Node           { return n.Node }
func (n TsAmbientPropertyMember) JsNode() *Node      { return n.Node }
func (n TsAmbientTypeAlias) JsNode() *Node           { return n.Node }
func (n TsAmbientVar) JsNode() *Node                 { return n.Node }
func (n TsAsExpression) JsNode() *Node               { return n.Node }
func (n TsCastExpression) JsNode() *Node             { return n.Node }
func (n TsConditional) JsNode() *Node                { return n.Node }
func (n TsDynamicImport) JsNode() *Node              { return n.Node }
func (n TsEnum) JsNode() *Node                       { return n.Node }
func (n TsEnumBody) JsNode() *Node                   { return n.Node }
func (n TsEnumMember) JsNode() *Node                 { return n.Node }
func (n TsExclToken) JsNode() *Node                  { return n.Node }
func (n TsExportAssignment) JsNode() *Node           { return n.Node }
func (n TsImplementsClause) JsNode() *Node           { return n.Node }
func (n TsImportAliasDeclaration) JsNode() *Node     { return n.Node }
func (n TsImportRequireDeclaration) JsNode() *Node   { return n.Node }
func (n TsIndexMemberDeclaration) JsNode() *Node     { return n.Node }
func (n TsInterface) JsNode() *Node                  { return n.Node }
func (n TsInterfaceExtends) JsNode() *Node           { return n.Node }
func (n TsNamespace) JsNode() *Node                  { return n.Node }
func (n TsNamespaceBody) JsNode() *Node              { return n.Node }
func (n TsNamespaceExportDeclaration) JsNode() *Node { return n.Node }
func (n TsNonNull) JsNode() *Node                    { return n.Node }
func (n TsThisParameter) JsNode() *Node              { return n.Node }
func (n TupleType) JsNode() *Node                    { return n.Node }
func (n TypeAliasDeclaration) JsNode() *Node         { return n.Node }
func (n TypeAnnotation) JsNode() *Node               { return n.Node }
func (n TypeArguments) JsNode() *Node                { return n.Node }
func (n TypeConstraint) JsNode() *Node               { return n.Node }
func (n TypeName) JsNode() *Node                     { return n.Node }
func (n TypeParameter) JsNode() *Node                { return n.Node }
func (n TypeParameters) JsNode() *Node               { return n.Node }
func (n TypePredicate) JsNode() *Node                { return n.Node }
func (n TypeQuery) JsNode() *Node                    { return n.Node }
func (n TypeReference) JsNode() *Node                { return n.Node }
func (n TypeVar) JsNode() *Node                      { return n.Node }
func (n UnaryExpression) JsNode() *Node              { return n.Node }
func (n UnionType) JsNode() *Node                    { return n.Node }
func (n UniqueType) JsNode() *Node                   { return n.Node }
func (n VariableDeclaration) JsNode() *Node          { return n.Node }
func (n VariableStatement) JsNode() *Node            { return n.Node }
func (n WhileStatement) JsNode() *Node               { return n.Node }
func (n WithStatement) JsNode() *Node                { return n.Node }
func (n Yield) JsNode() *Node                        { return n.Node }
func (n Token) JsNode() *Node                        { return n.Node }
func (NilNode) JsNode() *Node                        { return nil }

type BindingPattern interface {
	JsNode
	bindingPatternNode()
}

// bindingPatternNode() ensures that only the following types can be
// assigned to BindingPattern.
//
func (ArrayPattern) bindingPatternNode()  {}
func (ObjectPattern) bindingPatternNode() {}
func (NilNode) bindingPatternNode()       {}

type CaseClause interface {
	JsNode
	caseClauseNode()
}

// caseClauseNode() ensures that only the following types can be
// assigned to CaseClause.
//
func (Case) caseClauseNode()    {}
func (Default) caseClauseNode() {}
func (NilNode) caseClauseNode() {}

type ClassElement interface {
	JsNode
	classElementNode()
}

// classElementNode() ensures that only the following types can be
// assigned to ClassElement.
//
func (EmptyDecl) classElementNode()                {}
func (MemberMethod) classElementNode()             {}
func (MemberVar) classElementNode()                {}
func (TsIndexMemberDeclaration) classElementNode() {}
func (NilNode) classElementNode()                  {}

type Declaration interface {
	JsNode
	declarationNode()
}

// declarationNode() ensures that only the following types can be
// assigned to Declaration.
//
func (AsyncFunction) declarationNode()            {}
func (Class) declarationNode()                    {}
func (Function) declarationNode()                 {}
func (Generator) declarationNode()                {}
func (LexicalDeclaration) declarationNode()       {}
func (TsAmbientClass) declarationNode()           {}
func (TsAmbientEnum) declarationNode()            {}
func (TsAmbientFunction) declarationNode()        {}
func (TsAmbientImportAlias) declarationNode()     {}
func (TsAmbientInterface) declarationNode()       {}
func (TsAmbientModule) declarationNode()          {}
func (TsAmbientNamespace) declarationNode()       {}
func (TsAmbientTypeAlias) declarationNode()       {}
func (TsAmbientVar) declarationNode()             {}
func (TsEnum) declarationNode()                   {}
func (TsImportAliasDeclaration) declarationNode() {}
func (TsInterface) declarationNode()              {}
func (TsNamespace) declarationNode()              {}
func (TypeAliasDeclaration) declarationNode()     {}
func (NilNode) declarationNode()                  {}

type Decorator interface {
	JsNode
	decoratorNode()
}

// decoratorNode() ensures that only the following types can be
// assigned to Decorator.
//
func (DecoratorCall) decoratorNode() {}
func (DecoratorExpr) decoratorNode() {}
func (NilNode) decoratorNode()       {}

type ElementPattern interface {
	JsNode
	elementPatternNode()
}

// elementPatternNode() ensures that only the following types can be
// assigned to ElementPattern.
//
func (ElementBinding) elementPatternNode()    {}
func (SingleNameBinding) elementPatternNode() {}
func (SyntaxProblem) elementPatternNode()     {}
func (NilNode) elementPatternNode()           {}

type ExportElement interface {
	JsNode
	exportElementNode()
}

// exportElementNode() ensures that only the following types can be
// assigned to ExportElement.
//
func (ExportSpecifier) exportElementNode() {}
func (SyntaxProblem) exportElementNode()   {}
func (NilNode) exportElementNode()         {}

type Expression interface {
	JsNode
	expressionNode()
}

// expressionNode() ensures that only the following types can be
// assigned to Expression.
//
func (AdditiveExpression) expressionNode()       {}
func (ArrayLiteral) expressionNode()             {}
func (ArrowFunction) expressionNode()            {}
func (AssignmentExpression) expressionNode()     {}
func (AsyncArrowFunction) expressionNode()       {}
func (AsyncFunctionExpression) expressionNode()  {}
func (AwaitExpression) expressionNode()          {}
func (BitwiseANDExpression) expressionNode()     {}
func (BitwiseORExpression) expressionNode()      {}
func (BitwiseXORExpression) expressionNode()     {}
func (CallExpression) expressionNode()           {}
func (ClassExpr) expressionNode()                {}
func (CoalesceExpression) expressionNode()       {}
func (CommaExpression) expressionNode()          {}
func (ConditionalExpression) expressionNode()    {}
func (EqualityExpression) expressionNode()       {}
func (ExponentiationExpression) expressionNode() {}
func (FunctionExpression) expressionNode()       {}
func (GeneratorExpression) expressionNode()      {}
func (IdentifierReference) expressionNode()      {}
func (IndexAccess) expressionNode()              {}
func (JSXElement) expressionNode()               {}
func (Literal) expressionNode()                  {}
func (LogicalANDExpression) expressionNode()     {}
func (LogicalORExpression) expressionNode()      {}
func (MultiplicativeExpression) expressionNode() {}
func (NewExpression) expressionNode()            {}
func (NewTarget) expressionNode()                {}
func (ObjectLiteral) expressionNode()            {}
func (OptionalCallExpression) expressionNode()   {}
func (OptionalIndexAccess) expressionNode()      {}
func (OptionalPropertyAccess) expressionNode()   {}
func (OptionalTaggedTemplate) expressionNode()   {}
func (Parenthesized) expressionNode()            {}
func (PostDec) expressionNode()                  {}
func (PostInc) expressionNode()                  {}
func (PreDec) expressionNode()                   {}
func (PreInc) expressionNode()                   {}
func (PropertyAccess) expressionNode()           {}
func (Regexp) expressionNode()                   {}
func (RelationalExpression) expressionNode()     {}
func (ShiftExpression) expressionNode()          {}
func (SpreadElement) expressionNode()            {}
func (SuperExpression) expressionNode()          {}
func (TaggedTemplate) expressionNode()           {}
func (TemplateLiteral) expressionNode()          {}
func (This) expressionNode()                     {}
func (TsAsExpression) expressionNode()           {}
func (TsCastExpression) expressionNode()         {}
func (TsDynamicImport) expressionNode()          {}
func (TsNonNull) expressionNode()                {}
func (UnaryExpression) expressionNode()          {}
func (Yield) expressionNode()                    {}
func (NilNode) expressionNode()                  {}

type JSXAttribute interface {
	JsNode
	jSXAttributeNode()
}

// jSXAttributeNode() ensures that only the following types can be
// assigned to JSXAttribute.
//
func (JSXNormalAttribute) jSXAttributeNode() {}
func (JSXSpreadAttribute) jSXAttributeNode() {}
func (NilNode) jSXAttributeNode()            {}

type JSXAttributeValue interface {
	JsNode
	jSXAttributeValueNode()
}

// jSXAttributeValueNode() ensures that only the following types can be
// assigned to JSXAttributeValue.
//
func (JSXElement) jSXAttributeValueNode()    {}
func (JSXExpression) jSXAttributeValueNode() {}
func (JSXLiteral) jSXAttributeValueNode()    {}
func (NilNode) jSXAttributeValueNode()       {}

type JSXChild interface {
	JsNode
	jSXChildNode()
}

// jSXChildNode() ensures that only the following types can be
// assigned to JSXChild.
//
func (JSXElement) jSXChildNode()          {}
func (JSXExpression) jSXChildNode()       {}
func (JSXSpreadExpression) jSXChildNode() {}
func (JSXText) jSXChildNode()             {}
func (NilNode) jSXChildNode()             {}

type MethodDefinition interface {
	JsNode
	methodDefinitionNode()
}

// methodDefinitionNode() ensures that only the following types can be
// assigned to MethodDefinition.
//
func (AsyncMethod) methodDefinitionNode()     {}
func (GeneratorMethod) methodDefinitionNode() {}
func (Getter) methodDefinitionNode()          {}
func (Method) methodDefinitionNode()          {}
func (Setter) methodDefinitionNode()          {}
func (NilNode) methodDefinitionNode()         {}

type Modifier interface {
	JsNode
	modifierNode()
}

// modifierNode() ensures that only the following types can be
// assigned to Modifier.
//
func (Abstract) modifierNode()              {}
func (AccessibilityModifier) modifierNode() {}
func (DecoratorCall) modifierNode()         {}
func (DecoratorExpr) modifierNode()         {}
func (Readonly) modifierNode()              {}
func (Static) modifierNode()                {}
func (NilNode) modifierNode()               {}

type ModuleItem interface {
	JsNode
	moduleItemNode()
}

// moduleItemNode() ensures that only the following types can be
// assigned to ModuleItem.
//
func (AsyncFunction) moduleItemNode()                {}
func (Block) moduleItemNode()                        {}
func (BreakStatement) moduleItemNode()               {}
func (Class) moduleItemNode()                        {}
func (ContinueStatement) moduleItemNode()            {}
func (DebuggerStatement) moduleItemNode()            {}
func (DoWhileStatement) moduleItemNode()             {}
func (EmptyStatement) moduleItemNode()               {}
func (ExportDeclaration) moduleItemNode()            {}
func (ExportDefault) moduleItemNode()                {}
func (ExpressionStatement) moduleItemNode()          {}
func (ForInStatement) moduleItemNode()               {}
func (ForInStatementWithVar) moduleItemNode()        {}
func (ForOfStatement) moduleItemNode()               {}
func (ForOfStatementWithVar) moduleItemNode()        {}
func (ForStatement) moduleItemNode()                 {}
func (ForStatementWithVar) moduleItemNode()          {}
func (Function) moduleItemNode()                     {}
func (Generator) moduleItemNode()                    {}
func (IfStatement) moduleItemNode()                  {}
func (ImportDeclaration) moduleItemNode()            {}
func (LabelledStatement) moduleItemNode()            {}
func (LexicalDeclaration) moduleItemNode()           {}
func (ReturnStatement) moduleItemNode()              {}
func (SwitchStatement) moduleItemNode()              {}
func (SyntaxProblem) moduleItemNode()                {}
func (ThrowStatement) moduleItemNode()               {}
func (TryStatement) moduleItemNode()                 {}
func (TsAmbientClass) moduleItemNode()               {}
func (TsAmbientEnum) moduleItemNode()                {}
func (TsAmbientFunction) moduleItemNode()            {}
func (TsAmbientImportAlias) moduleItemNode()         {}
func (TsAmbientInterface) moduleItemNode()           {}
func (TsAmbientModule) moduleItemNode()              {}
func (TsAmbientNamespace) moduleItemNode()           {}
func (TsAmbientTypeAlias) moduleItemNode()           {}
func (TsAmbientVar) moduleItemNode()                 {}
func (TsEnum) moduleItemNode()                       {}
func (TsExportAssignment) moduleItemNode()           {}
func (TsImportAliasDeclaration) moduleItemNode()     {}
func (TsImportRequireDeclaration) moduleItemNode()   {}
func (TsInterface) moduleItemNode()                  {}
func (TsNamespace) moduleItemNode()                  {}
func (TsNamespaceExportDeclaration) moduleItemNode() {}
func (TypeAliasDeclaration) moduleItemNode()         {}
func (VariableStatement) moduleItemNode()            {}
func (WhileStatement) moduleItemNode()               {}
func (WithStatement) moduleItemNode()                {}
func (NilNode) moduleItemNode()                      {}

type NamedImport interface {
	JsNode
	namedImportNode()
}

// namedImportNode() ensures that only the following types can be
// assigned to NamedImport.
//
func (ImportSpecifier) namedImportNode() {}
func (SyntaxProblem) namedImportNode()   {}
func (NilNode) namedImportNode()         {}

type Parameter interface {
	JsNode
	parameterNode()
}

// parameterNode() ensures that only the following types can be
// assigned to Parameter.
//
func (DefaultParameter) parameterNode() {}
func (RestParameter) parameterNode()    {}
func (SyntaxProblem) parameterNode()    {}
func (TsThisParameter) parameterNode()  {}
func (NilNode) parameterNode()          {}

type PropertyDefinition interface {
	JsNode
	propertyDefinitionNode()
}

// propertyDefinitionNode() ensures that only the following types can be
// assigned to PropertyDefinition.
//
func (ObjectMethod) propertyDefinitionNode()      {}
func (Property) propertyDefinitionNode()          {}
func (ShorthandProperty) propertyDefinitionNode() {}
func (SpreadProperty) propertyDefinitionNode()    {}
func (SyntaxProblem) propertyDefinitionNode()     {}
func (NilNode) propertyDefinitionNode()           {}

type PropertyName interface {
	JsNode
	propertyNameNode()
}

// propertyNameNode() ensures that only the following types can be
// assigned to PropertyName.
//
func (ComputedPropertyName) propertyNameNode() {}
func (LiteralPropertyName) propertyNameNode()  {}
func (NilNode) propertyNameNode()              {}

type PropertyPattern interface {
	JsNode
	propertyPatternNode()
}

// propertyPatternNode() ensures that only the following types can be
// assigned to PropertyPattern.
//
func (PropertyBinding) propertyPatternNode()   {}
func (SingleNameBinding) propertyPatternNode() {}
func (SyntaxProblem) propertyPatternNode()     {}
func (NilNode) propertyPatternNode()           {}

type Statement interface {
	JsNode
	statementNode()
}

// statementNode() ensures that only the following types can be
// assigned to Statement.
//
func (Block) statementNode()                 {}
func (BreakStatement) statementNode()        {}
func (ContinueStatement) statementNode()     {}
func (DebuggerStatement) statementNode()     {}
func (DoWhileStatement) statementNode()      {}
func (EmptyStatement) statementNode()        {}
func (ExpressionStatement) statementNode()   {}
func (ForInStatement) statementNode()        {}
func (ForInStatementWithVar) statementNode() {}
func (ForOfStatement) statementNode()        {}
func (ForOfStatementWithVar) statementNode() {}
func (ForStatement) statementNode()          {}
func (ForStatementWithVar) statementNode()   {}
func (IfStatement) statementNode()           {}
func (LabelledStatement) statementNode()     {}
func (ReturnStatement) statementNode()       {}
func (SwitchStatement) statementNode()       {}
func (ThrowStatement) statementNode()        {}
func (TryStatement) statementNode()          {}
func (VariableStatement) statementNode()     {}
func (WhileStatement) statementNode()        {}
func (WithStatement) statementNode()         {}
func (NilNode) statementNode()               {}

type StatementListItem interface {
	JsNode
	statementListItemNode()
}

// statementListItemNode() ensures that only the following types can be
// assigned to StatementListItem.
//
func (AsyncFunction) statementListItemNode()            {}
func (Block) statementListItemNode()                    {}
func (BreakStatement) statementListItemNode()           {}
func (Class) statementListItemNode()                    {}
func (ContinueStatement) statementListItemNode()        {}
func (DebuggerStatement) statementListItemNode()        {}
func (DoWhileStatement) statementListItemNode()         {}
func (EmptyStatement) statementListItemNode()           {}
func (ExpressionStatement) statementListItemNode()      {}
func (ForInStatement) statementListItemNode()           {}
func (ForInStatementWithVar) statementListItemNode()    {}
func (ForOfStatement) statementListItemNode()           {}
func (ForOfStatementWithVar) statementListItemNode()    {}
func (ForStatement) statementListItemNode()             {}
func (ForStatementWithVar) statementListItemNode()      {}
func (Function) statementListItemNode()                 {}
func (Generator) statementListItemNode()                {}
func (IfStatement) statementListItemNode()              {}
func (LabelledStatement) statementListItemNode()        {}
func (LexicalDeclaration) statementListItemNode()       {}
func (ReturnStatement) statementListItemNode()          {}
func (SwitchStatement) statementListItemNode()          {}
func (SyntaxProblem) statementListItemNode()            {}
func (ThrowStatement) statementListItemNode()           {}
func (TryStatement) statementListItemNode()             {}
func (TsAmbientClass) statementListItemNode()           {}
func (TsAmbientEnum) statementListItemNode()            {}
func (TsAmbientFunction) statementListItemNode()        {}
func (TsAmbientImportAlias) statementListItemNode()     {}
func (TsAmbientInterface) statementListItemNode()       {}
func (TsAmbientModule) statementListItemNode()          {}
func (TsAmbientNamespace) statementListItemNode()       {}
func (TsAmbientTypeAlias) statementListItemNode()       {}
func (TsAmbientVar) statementListItemNode()             {}
func (TsEnum) statementListItemNode()                   {}
func (TsImportAliasDeclaration) statementListItemNode() {}
func (TsInterface) statementListItemNode()              {}
func (TsNamespace) statementListItemNode()              {}
func (TypeAliasDeclaration) statementListItemNode()     {}
func (VariableStatement) statementListItemNode()        {}
func (WhileStatement) statementListItemNode()           {}
func (WithStatement) statementListItemNode()            {}
func (NilNode) statementListItemNode()                  {}

type TsAmbientClassElement interface {
	JsNode
	tsAmbientClassElementNode()
}

// tsAmbientClassElementNode() ensures that only the following types can be
// assigned to TsAmbientClassElement.
//
func (TsAmbientFunctionMember) tsAmbientClassElementNode() {}
func (TsAmbientIndexMember) tsAmbientClassElementNode()    {}
func (TsAmbientPropertyMember) tsAmbientClassElementNode() {}
func (NilNode) tsAmbientClassElementNode()                 {}

type TsAmbientElement interface {
	JsNode
	tsAmbientElementNode()
}

// tsAmbientElementNode() ensures that only the following types can be
// assigned to TsAmbientElement.
//
func (TsAmbientClass) tsAmbientElementNode()       {}
func (TsAmbientEnum) tsAmbientElementNode()        {}
func (TsAmbientFunction) tsAmbientElementNode()    {}
func (TsAmbientImportAlias) tsAmbientElementNode() {}
func (TsAmbientInterface) tsAmbientElementNode()   {}
func (TsAmbientModule) tsAmbientElementNode()      {}
func (TsAmbientNamespace) tsAmbientElementNode()   {}
func (TsAmbientTypeAlias) tsAmbientElementNode()   {}
func (TsAmbientVar) tsAmbientElementNode()         {}
func (NilNode) tsAmbientElementNode()              {}

type TsType interface {
	JsNode
	tsTypeNode()
}

// tsTypeNode() ensures that only the following types can be
// assigned to TsType.
//
func (ArrayType) tsTypeNode()         {}
func (ConstructorType) tsTypeNode()   {}
func (FunctionType) tsTypeNode()      {}
func (ImportType) tsTypeNode()        {}
func (IndexedAccessType) tsTypeNode() {}
func (IntersectionType) tsTypeNode()  {}
func (KeyOfType) tsTypeNode()         {}
func (LiteralType) tsTypeNode()       {}
func (MappedType) tsTypeNode()        {}
func (NonNullableType) tsTypeNode()   {}
func (NullableType) tsTypeNode()      {}
func (ObjectType) tsTypeNode()        {}
func (ParenthesizedType) tsTypeNode() {}
func (PredefinedType) tsTypeNode()    {}
func (ReadonlyType) tsTypeNode()      {}
func (RestType) tsTypeNode()          {}
func (ThisType) tsTypeNode()          {}
func (TsConditional) tsTypeNode()     {}
func (TupleType) tsTypeNode()         {}
func (TypePredicate) tsTypeNode()     {}
func (TypeQuery) tsTypeNode()         {}
func (TypeReference) tsTypeNode()     {}
func (TypeVar) tsTypeNode()           {}
func (UnionType) tsTypeNode()         {}
func (UniqueType) tsTypeNode()        {}
func (NilNode) tsTypeNode()           {}

type TypeMember interface {
	JsNode
	typeMemberNode()
}

// typeMemberNode() ensures that only the following types can be
// assigned to TypeMember.
//
func (CallSignature) typeMemberNode()      {}
func (ConstructSignature) typeMemberNode() {}
func (IndexSignature) typeMemberNode()     {}
func (MethodSignature) typeMemberNode()    {}
func (PropertySignature) typeMemberNode()  {}
func (NilNode) typeMemberNode()            {}

// Types.

type Abstract struct {
	*Node
}

type AccessibilityModifier struct {
	*Node
}

type AdditiveExpression struct {
	*Node
}

func (n AdditiveExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n AdditiveExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type Arguments struct {
	*Node
}

func (n Arguments) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

func (n Arguments) List() []Expression {
	nodes := n.Children(selector.Expression)
	var ret = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expression))
	}
	return ret
}

type ArrayLiteral struct {
	*Node
}

func (n ArrayLiteral) List() []Expression {
	nodes := n.Children(selector.Expression)
	var ret = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expression))
	}
	return ret
}

type ArrayPattern struct {
	*Node
}

func (n ArrayPattern) ElementPattern() []ElementPattern {
	nodes := n.Children(selector.ElementPattern)
	var ret = make([]ElementPattern, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ElementPattern))
	}
	return ret
}

func (n ArrayPattern) BindingRestElement() (BindingRestElement, bool) {
	field := BindingRestElement{n.Child(selector.BindingRestElement)}
	return field, field.IsValid()
}

type ArrayType struct {
	*Node
}

func (n ArrayType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ArrowFunction struct {
	*Node
}

func (n ArrowFunction) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n ArrowFunction) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n ArrowFunction) Parameters() (Parameters, bool) {
	field := Parameters{n.Child(selector.Parameters)}
	return field, field.IsValid()
}

func (n ArrowFunction) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n ArrowFunction) Body() (Body, bool) {
	field := Body{n.Child(selector.Body)}
	return field, field.IsValid()
}

func (n ArrowFunction) ConciseBody() (ConciseBody, bool) {
	field := ConciseBody{n.Child(selector.ConciseBody)}
	return field, field.IsValid()
}

type AssignmentExpression struct {
	*Node
}

func (n AssignmentExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n AssignmentExpression) AssignmentOperator() (AssignmentOperator, bool) {
	field := AssignmentOperator{n.Child(selector.AssignmentOperator)}
	return field, field.IsValid()
}

func (n AssignmentExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type AssignmentOperator struct {
	*Node
}

type AsyncArrowFunction struct {
	*Node
}

func (n AsyncArrowFunction) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n AsyncArrowFunction) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n AsyncArrowFunction) Parameters() (Parameters, bool) {
	field := Parameters{n.Child(selector.Parameters)}
	return field, field.IsValid()
}

func (n AsyncArrowFunction) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n AsyncArrowFunction) Body() (Body, bool) {
	field := Body{n.Child(selector.Body)}
	return field, field.IsValid()
}

func (n AsyncArrowFunction) ConciseBody() (ConciseBody, bool) {
	field := ConciseBody{n.Child(selector.ConciseBody)}
	return field, field.IsValid()
}

type AsyncFunction struct {
	*Node
}

func (n AsyncFunction) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n AsyncFunction) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n AsyncFunction) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncFunction) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n AsyncFunction) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AsyncFunctionExpression struct {
	*Node
}

func (n AsyncFunctionExpression) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n AsyncFunctionExpression) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n AsyncFunctionExpression) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncFunctionExpression) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n AsyncFunctionExpression) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AsyncMethod struct {
	*Node
}

func (n AsyncMethod) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n AsyncMethod) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n AsyncMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncMethod) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n AsyncMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AwaitExpression struct {
	*Node
}

func (n AwaitExpression) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type BindingIdentifier struct {
	*Node
}

type BindingRestElement struct {
	*Node
}

func (n BindingRestElement) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type BitwiseANDExpression struct {
	*Node
}

func (n BitwiseANDExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseANDExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type BitwiseORExpression struct {
	*Node
}

func (n BitwiseORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type BitwiseXORExpression struct {
	*Node
}

func (n BitwiseXORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseXORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type Block struct {
	*Node
}

func (n Block) CaseClause() []CaseClause {
	nodes := n.Children(selector.CaseClause)
	var ret = make([]CaseClause, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(CaseClause))
	}
	return ret
}

func (n Block) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var ret = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StatementListItem))
	}
	return ret
}

type Body struct {
	*Node
}

func (n Body) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var ret = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StatementListItem))
	}
	return ret
}

type BreakStatement struct {
	*Node
}

func (n BreakStatement) LabelIdentifier() (LabelIdentifier, bool) {
	field := LabelIdentifier{n.Child(selector.LabelIdentifier)}
	return field, field.IsValid()
}

type CallExpression struct {
	*Node
}

func (n CallExpression) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n CallExpression) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type CallSignature struct {
	*Node
}

func (n CallSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n CallSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n CallSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type Case struct {
	*Node
}

func (n Case) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n Case) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var ret = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StatementListItem))
	}
	return ret
}

type Catch struct {
	*Node
}

func (n Catch) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n Catch) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n Catch) Block() Block {
	return Block{n.Child(selector.Block)}
}

type Class struct {
	*Node
}

func (n Class) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n Class) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n Class) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n Class) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()
}

func (n Class) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()
}

func (n Class) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type ClassBody struct {
	*Node
}

func (n ClassBody) ClassElement() []ClassElement {
	nodes := n.Children(selector.ClassElement)
	var ret = make([]ClassElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ClassElement))
	}
	return ret
}

type ClassExpr struct {
	*Node
}

func (n ClassExpr) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ClassExpr) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n ClassExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n ClassExpr) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()
}

func (n ClassExpr) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()
}

func (n ClassExpr) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type CoalesceExpression struct {
	*Node
}

func (n CoalesceExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n CoalesceExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type CommaExpression struct {
	*Node
}

func (n CommaExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n CommaExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ComputedPropertyName struct {
	*Node
}

func (n ComputedPropertyName) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ConciseBody struct {
	*Node
}

func (n ConciseBody) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ConditionalExpression struct {
	*Node
}

func (n ConditionalExpression) Cond() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ConditionalExpression) Then() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

func (n ConditionalExpression) Else() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression).Next(selector.Expression)).(Expression)
}

type ConstructSignature struct {
	*Node
}

func (n ConstructSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ConstructSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n ConstructSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ConstructSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type ConstructorType struct {
	*Node
}

func (n ConstructorType) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n ConstructorType) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ConstructorType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ContinueStatement struct {
	*Node
}

func (n ContinueStatement) LabelIdentifier() (LabelIdentifier, bool) {
	field := LabelIdentifier{n.Child(selector.LabelIdentifier)}
	return field, field.IsValid()
}

type DebuggerStatement struct {
	*Node
}

type DecoratorCall struct {
	*Node
}

func (n DecoratorCall) IdentifierReference() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var ret = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, IdentifierReference{node})
	}
	return ret
}

func (n DecoratorCall) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type DecoratorExpr struct {
	*Node
}

func (n DecoratorExpr) IdentifierReference() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var ret = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, IdentifierReference{node})
	}
	return ret
}

type Default struct {
	*Node
}

func (n Default) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var ret = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StatementListItem))
	}
	return ret
}

type DefaultParameter struct {
	*Node
}

func (n DefaultParameter) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n DefaultParameter) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n DefaultParameter) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n DefaultParameter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n DefaultParameter) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type DoWhileStatement struct {
	*Node
}

func (n DoWhileStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

func (n DoWhileStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ElementBinding struct {
	*Node
}

func (n ElementBinding) BindingPattern() BindingPattern {
	return ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
}

func (n ElementBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type EmptyDecl struct {
	*Node
}

type EmptyStatement struct {
	*Node
}

type EqualityExpression struct {
	*Node
}

func (n EqualityExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n EqualityExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ExponentiationExpression struct {
	*Node
}

func (n ExponentiationExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ExponentiationExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ExportClause struct {
	*Node
}

func (n ExportClause) ExportElement() []ExportElement {
	nodes := n.Children(selector.ExportElement)
	var ret = make([]ExportElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ExportElement))
	}
	return ret
}

type ExportDeclaration struct {
	*Node
}

func (n ExportDeclaration) ExportClause() (ExportClause, bool) {
	field := ExportClause{n.Child(selector.ExportClause)}
	return field, field.IsValid()
}

func (n ExportDeclaration) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ExportDeclaration) VariableStatement() (VariableStatement, bool) {
	field := VariableStatement{n.Child(selector.VariableStatement)}
	return field, field.IsValid()
}

func (n ExportDeclaration) Declaration() (Declaration, bool) {
	field := ToJsNode(n.Child(selector.Declaration)).(Declaration)
	return field, field.JsNode() != nil
}

func (n ExportDeclaration) ModuleSpecifier() (ModuleSpecifier, bool) {
	field := ModuleSpecifier{n.Child(selector.ModuleSpecifier)}
	return field, field.IsValid()
}

type ExportDefault struct {
	*Node
}

func (n ExportDefault) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

func (n ExportDefault) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ExportDefault) Declaration() (Declaration, bool) {
	field := ToJsNode(n.Child(selector.Declaration)).(Declaration)
	return field, field.JsNode() != nil
}

type ExportSpecifier struct {
	*Node
}

func (n ExportSpecifier) IdentifierReference() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

func (n ExportSpecifier) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

type ExpressionStatement struct {
	*Node
}

func (n ExpressionStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type Extends struct {
	*Node
}

func (n Extends) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

func (n Extends) TypeReference() (TypeReference, bool) {
	field := TypeReference{n.Child(selector.TypeReference)}
	return field, field.IsValid()
}

type Finally struct {
	*Node
}

func (n Finally) Block() Block {
	return Block{n.Child(selector.Block)}
}

type ForBinding struct {
	*Node
}

func (n ForBinding) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n ForBinding) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

type ForCondition struct {
	*Node
}

func (n ForCondition) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

type ForFinalExpression struct {
	*Node
}

func (n ForFinalExpression) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

type ForInStatement struct {
	*Node
}

func (n ForInStatement) Var() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForInStatement) Object() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

func (n ForInStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForInStatementWithVar struct {
	*Node
}

func (n ForInStatementWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForInStatementWithVar) Object() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForInStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForOfStatement struct {
	*Node
}

func (n ForOfStatement) Var() JsNode {
	return ToJsNode(n.Child(selector.OneOf(js.AdditiveExpression, js.ArrayLiteral, js.ArrowFunction, js.AssignmentExpression, js.AsyncArrowFunction, js.AsyncFunctionExpression, js.AwaitExpression, js.BitwiseANDExpression, js.BitwiseORExpression, js.BitwiseXORExpression, js.CallExpression, js.ClassExpr, js.CoalesceExpression, js.CommaExpression, js.ConditionalExpression, js.EqualityExpression, js.ExponentiationExpression, js.FunctionExpression, js.GeneratorExpression, js.IdentifierReference, js.IndexAccess, js.JSXElement, js.Literal, js.LogicalANDExpression, js.LogicalORExpression, js.MultiplicativeExpression, js.NewExpression, js.NewTarget, js.ObjectLiteral, js.OptionalCallExpression, js.OptionalIndexAccess, js.OptionalPropertyAccess, js.OptionalTaggedTemplate, js.Parenthesized, js.PostDec, js.PostInc, js.PreDec, js.PreInc, js.PropertyAccess, js.Regexp, js.RelationalExpression, js.ShiftExpression, js.SpreadElement, js.SuperExpression, js.TaggedTemplate, js.TemplateLiteral, js.This, js.TsAsExpression, js.TsCastExpression, js.TsDynamicImport, js.TsNonNull, js.UnaryExpression, js.Yield))).(JsNode)
}

func (n ForOfStatement) Iterable() Expression {
	return ToJsNode(n.Child(selector.OneOf(js.AdditiveExpression, js.ArrayLiteral, js.ArrowFunction, js.AssignmentExpression, js.AsyncArrowFunction, js.AsyncFunctionExpression, js.AwaitExpression, js.BitwiseANDExpression, js.BitwiseORExpression, js.BitwiseXORExpression, js.CallExpression, js.ClassExpr, js.CoalesceExpression, js.CommaExpression, js.ConditionalExpression, js.EqualityExpression, js.ExponentiationExpression, js.FunctionExpression, js.GeneratorExpression, js.IdentifierReference, js.IndexAccess, js.JSXElement, js.Literal, js.LogicalANDExpression, js.LogicalORExpression, js.MultiplicativeExpression, js.NewExpression, js.NewTarget, js.ObjectLiteral, js.OptionalCallExpression, js.OptionalIndexAccess, js.OptionalPropertyAccess, js.OptionalTaggedTemplate, js.Parenthesized, js.PostDec, js.PostInc, js.PreDec, js.PreInc, js.PropertyAccess, js.Regexp, js.RelationalExpression, js.ShiftExpression, js.SpreadElement, js.SuperExpression, js.TaggedTemplate, js.TemplateLiteral, js.This, js.TsAsExpression, js.TsCastExpression, js.TsDynamicImport, js.TsNonNull, js.UnaryExpression, js.Yield)).Next(selector.Expression)).(Expression)
}

func (n ForOfStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForOfStatementWithVar struct {
	*Node
}

func (n ForOfStatementWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForOfStatementWithVar) Iterable() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForOfStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForStatement struct {
	*Node
}

func (n ForStatement) Var() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

func (n ForStatement) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStatement) ForFinalExpression() ForFinalExpression {
	return ForFinalExpression{n.Child(selector.ForFinalExpression)}
}

func (n ForStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForStatementWithVar struct {
	*Node
}

func (n ForStatementWithVar) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var ret = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, LexicalBinding{node})
	}
	return ret
}

func (n ForStatementWithVar) VariableDeclaration() []VariableDeclaration {
	nodes := n.Children(selector.VariableDeclaration)
	var ret = make([]VariableDeclaration, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, VariableDeclaration{node})
	}
	return ret
}

func (n ForStatementWithVar) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStatementWithVar) ForFinalExpression() ForFinalExpression {
	return ForFinalExpression{n.Child(selector.ForFinalExpression)}
}

func (n ForStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type Function struct {
	*Node
}

func (n Function) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n Function) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n Function) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Function) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n Function) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FunctionExpression struct {
	*Node
}

func (n FunctionExpression) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n FunctionExpression) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n FunctionExpression) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FunctionExpression) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n FunctionExpression) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FunctionType struct {
	*Node
}

func (n FunctionType) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n FunctionType) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FunctionType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type Generator struct {
	*Node
}

func (n Generator) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n Generator) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n Generator) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Generator) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n Generator) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorExpression struct {
	*Node
}

func (n GeneratorExpression) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n GeneratorExpression) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n GeneratorExpression) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorExpression) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n GeneratorExpression) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorMethod struct {
	*Node
}

func (n GeneratorMethod) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n GeneratorMethod) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n GeneratorMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorMethod) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n GeneratorMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type Getter struct {
	*Node
}

func (n Getter) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Getter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n Getter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type IdentifierReference struct {
	*Node
}

type IfStatement struct {
	*Node
}

func (n IfStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n IfStatement) Then() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

func (n IfStatement) Else() (Statement, bool) {
	field := ToJsNode(n.Child(selector.Statement).Next(selector.Statement)).(Statement)
	return field, field.JsNode() != nil
}

type ImportDeclaration struct {
	*Node
}

func (n ImportDeclaration) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n ImportDeclaration) NameSpaceImport() (NameSpaceImport, bool) {
	field := NameSpaceImport{n.Child(selector.NameSpaceImport)}
	return field, field.IsValid()
}

func (n ImportDeclaration) NamedImports() (NamedImports, bool) {
	field := NamedImports{n.Child(selector.NamedImports)}
	return field, field.IsValid()
}

func (n ImportDeclaration) ModuleSpecifier() ModuleSpecifier {
	return ModuleSpecifier{n.Child(selector.ModuleSpecifier)}
}

type ImportSpecifier struct {
	*Node
}

func (n ImportSpecifier) IdentifierReference() (IdentifierReference, bool) {
	field := IdentifierReference{n.Child(selector.IdentifierReference)}
	return field, field.IsValid()
}

func (n ImportSpecifier) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type ImportType struct {
	*Node
}

func (n ImportType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n ImportType) IdentifierReference() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var ret = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, IdentifierReference{node})
	}
	return ret
}

func (n ImportType) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

type IndexAccess struct {
	*Node
}

func (n IndexAccess) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n IndexAccess) Index() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type IndexSignature struct {
	*Node
}

func (n IndexSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n IndexSignature) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type IndexedAccessType struct {
	*Node
}

func (n IndexedAccessType) Left() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n IndexedAccessType) Index() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType)).(TsType)
}

type Initializer struct {
	*Node
}

func (n Initializer) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type IntersectionType struct {
	*Node
}

func (n IntersectionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type JSXAttributeName struct {
	*Node
}

type JSXClosingElement struct {
	*Node
}

func (n JSXClosingElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

type JSXElement struct {
	*Node
}

func (n JSXElement) JSXOpeningElement() (JSXOpeningElement, bool) {
	field := JSXOpeningElement{n.Child(selector.JSXOpeningElement)}
	return field, field.IsValid()
}

func (n JSXElement) JSXSelfClosingElement() (JSXSelfClosingElement, bool) {
	field := JSXSelfClosingElement{n.Child(selector.JSXSelfClosingElement)}
	return field, field.IsValid()
}

func (n JSXElement) JSXChild() []JSXChild {
	nodes := n.Children(selector.JSXChild)
	var ret = make([]JSXChild, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXChild))
	}
	return ret
}

func (n JSXElement) JSXClosingElement() (JSXClosingElement, bool) {
	field := JSXClosingElement{n.Child(selector.JSXClosingElement)}
	return field, field.IsValid()
}

type JSXElementName struct {
	*Node
}

type JSXExpression struct {
	*Node
}

func (n JSXExpression) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

type JSXLiteral struct {
	*Node
}

type JSXNormalAttribute struct {
	*Node
}

func (n JSXNormalAttribute) JSXAttributeName() JSXAttributeName {
	return JSXAttributeName{n.Child(selector.JSXAttributeName)}
}

func (n JSXNormalAttribute) JSXAttributeValue() (JSXAttributeValue, bool) {
	field := ToJsNode(n.Child(selector.JSXAttributeValue)).(JSXAttributeValue)
	return field, field.JsNode() != nil
}

type JSXOpeningElement struct {
	*Node
}

func (n JSXOpeningElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

func (n JSXOpeningElement) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

func (n JSXOpeningElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var ret = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXAttribute))
	}
	return ret
}

type JSXSelfClosingElement struct {
	*Node
}

func (n JSXSelfClosingElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

func (n JSXSelfClosingElement) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

func (n JSXSelfClosingElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var ret = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXAttribute))
	}
	return ret
}

type JSXSpreadAttribute struct {
	*Node
}

func (n JSXSpreadAttribute) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type JSXSpreadExpression struct {
	*Node
}

func (n JSXSpreadExpression) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

type JSXText struct {
	*Node
}

type KeyOfType struct {
	*Node
}

func (n KeyOfType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type LabelIdentifier struct {
	*Node
}

type LabelledStatement struct {
	*Node
}

func (n LabelledStatement) LabelIdentifier() LabelIdentifier {
	return LabelIdentifier{n.Child(selector.LabelIdentifier)}
}

func (n LabelledStatement) Function() (Function, bool) {
	field := Function{n.Child(selector.Function)}
	return field, field.IsValid()
}

func (n LabelledStatement) Statement() (Statement, bool) {
	field := ToJsNode(n.Child(selector.Statement)).(Statement)
	return field, field.JsNode() != nil
}

type LexicalBinding struct {
	*Node
}

func (n LexicalBinding) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n LexicalBinding) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n LexicalBinding) TsExclToken() (TsExclToken, bool) {
	field := TsExclToken{n.Child(selector.TsExclToken)}
	return field, field.IsValid()
}

func (n LexicalBinding) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n LexicalBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type LexicalDeclaration struct {
	*Node
}

func (n LexicalDeclaration) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var ret = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, LexicalBinding{node})
	}
	return ret
}

type Literal struct {
	*Node
}

type LiteralPropertyName struct {
	*Node
}

func (n LiteralPropertyName) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

type LiteralType struct {
	*Node
}

type LogicalANDExpression struct {
	*Node
}

func (n LogicalANDExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n LogicalANDExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type LogicalORExpression struct {
	*Node
}

func (n LogicalORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n LogicalORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type MappedType struct {
	*Node
}

func (n MappedType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n MappedType) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type MemberMethod struct {
	*Node
}

func (n MemberMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n MemberMethod) MethodDefinition() MethodDefinition {
	return ToJsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type MemberVar struct {
	*Node
}

func (n MemberVar) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n MemberVar) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n MemberVar) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n MemberVar) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type Method struct {
	*Node
}

func (n Method) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Method) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n Method) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Method) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n Method) Body() Body {
	return Body{n.Child(selector.Body)}
}

type MethodSignature struct {
	*Node
}

func (n MethodSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n MethodSignature) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n MethodSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n MethodSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n MethodSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type Module struct {
	*Node
}

func (n Module) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type ModuleSpecifier struct {
	*Node
}

type MultiplicativeExpression struct {
	*Node
}

func (n MultiplicativeExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n MultiplicativeExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type NameSpaceImport struct {
	*Node
}

func (n NameSpaceImport) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type NamedImports struct {
	*Node
}

func (n NamedImports) NamedImport() []NamedImport {
	nodes := n.Children(selector.NamedImport)
	var ret = make([]NamedImport, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(NamedImport))
	}
	return ret
}

type NewExpression struct {
	*Node
}

func (n NewExpression) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n NewExpression) Arguments() (Arguments, bool) {
	field := Arguments{n.Child(selector.Arguments)}
	return field, field.IsValid()
}

type NewTarget struct {
	*Node
}

type NonNullableType struct {
	*Node
}

func (n NonNullableType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type NullableType struct {
	*Node
}

func (n NullableType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ObjectLiteral struct {
	*Node
}

func (n ObjectLiteral) PropertyDefinition() []PropertyDefinition {
	nodes := n.Children(selector.PropertyDefinition)
	var ret = make([]PropertyDefinition, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(PropertyDefinition))
	}
	return ret
}

type ObjectMethod struct {
	*Node
}

func (n ObjectMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ObjectMethod) MethodDefinition() MethodDefinition {
	return ToJsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type ObjectPattern struct {
	*Node
}

func (n ObjectPattern) PropertyPattern() []PropertyPattern {
	nodes := n.Children(selector.PropertyPattern)
	var ret = make([]PropertyPattern, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(PropertyPattern))
	}
	return ret
}

func (n ObjectPattern) BindingRestElement() (BindingRestElement, bool) {
	field := BindingRestElement{n.Child(selector.BindingRestElement)}
	return field, field.IsValid()
}

type ObjectType struct {
	*Node
}

func (n ObjectType) TypeMember() []TypeMember {
	nodes := n.Children(selector.TypeMember)
	var ret = make([]TypeMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TypeMember))
	}
	return ret
}

type OptionalCallExpression struct {
	*Node
}

func (n OptionalCallExpression) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n OptionalCallExpression) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type OptionalIndexAccess struct {
	*Node
}

func (n OptionalIndexAccess) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n OptionalIndexAccess) Index() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type OptionalPropertyAccess struct {
	*Node
}

func (n OptionalPropertyAccess) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n OptionalPropertyAccess) Selector() IdentifierReference {
	return IdentifierReference{n.Child(selector.Expression).Next(selector.IdentifierReference)}
}

type OptionalTaggedTemplate struct {
	*Node
}

func (n OptionalTaggedTemplate) Tag() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n OptionalTaggedTemplate) Literal() TemplateLiteral {
	return TemplateLiteral{n.Child(selector.Expression).Next(selector.TemplateLiteral)}
}

type Parameters struct {
	*Node
}

func (n Parameters) Parameter() []Parameter {
	nodes := n.Children(selector.Parameter)
	var ret = make([]Parameter, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Parameter))
	}
	return ret
}

type Parenthesized struct {
	*Node
}

func (n Parenthesized) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

func (n Parenthesized) SyntaxProblem() (SyntaxProblem, bool) {
	field := SyntaxProblem{n.Child(selector.SyntaxProblem)}
	return field, field.IsValid()
}

type ParenthesizedType struct {
	*Node
}

func (n ParenthesizedType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type PostDec struct {
	*Node
}

func (n PostDec) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PostInc struct {
	*Node
}

func (n PostInc) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PreDec struct {
	*Node
}

func (n PreDec) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PreInc struct {
	*Node
}

func (n PreInc) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PredefinedType struct {
	*Node
}

type Property struct {
	*Node
}

func (n Property) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n Property) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Property) Value() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PropertyAccess struct {
	*Node
}

func (n PropertyAccess) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n PropertyAccess) Selector() IdentifierReference {
	return IdentifierReference{n.Child(selector.Expression).Next(selector.IdentifierReference)}
}

type PropertyBinding struct {
	*Node
}

func (n PropertyBinding) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertyBinding) ElementPattern() ElementPattern {
	return ToJsNode(n.Child(selector.ElementPattern)).(ElementPattern)
}

type PropertySignature struct {
	*Node
}

func (n PropertySignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n PropertySignature) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertySignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type Readonly struct {
	*Node
}

type ReadonlyType struct {
	*Node
}

func (n ReadonlyType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type Regexp struct {
	*Node
}

type RelationalExpression struct {
	*Node
}

func (n RelationalExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n RelationalExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type RestParameter struct {
	*Node
}

func (n RestParameter) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n RestParameter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type RestType struct {
	*Node
}

func (n RestType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ReturnStatement struct {
	*Node
}

func (n ReturnStatement) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

type Setter struct {
	*Node
}

func (n Setter) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Setter) Parameter() Parameter {
	return ToJsNode(n.Child(selector.Parameter)).(Parameter)
}

func (n Setter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type ShiftExpression struct {
	*Node
}

func (n ShiftExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ShiftExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ShorthandProperty struct {
	*Node
}

func (n ShorthandProperty) IdentifierReference() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

type SingleNameBinding struct {
	*Node
}

func (n SingleNameBinding) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n SingleNameBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type SpreadElement struct {
	*Node
}

func (n SpreadElement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type SpreadProperty struct {
	*Node
}

func (n SpreadProperty) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type Static struct {
	*Node
}

type SuperExpression struct {
	*Node
}

type SwitchStatement struct {
	*Node
}

func (n SwitchStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n SwitchStatement) Block() Block {
	return Block{n.Child(selector.Block)}
}

type SyntaxProblem struct {
	*Node
}

func (n SyntaxProblem) IdentifierReference() (IdentifierReference, bool) {
	field := IdentifierReference{n.Child(selector.IdentifierReference)}
	return field, field.IsValid()
}

func (n SyntaxProblem) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type TaggedTemplate struct {
	*Node
}

func (n TaggedTemplate) Tag() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n TaggedTemplate) Literal() TemplateLiteral {
	return TemplateLiteral{n.Child(selector.Expression).Next(selector.TemplateLiteral)}
}

type TemplateLiteral struct {
	*Node
}

func (n TemplateLiteral) Template() []Token {
	nodes := n.Children(selector.OneOf(js.NoSubstitutionTemplate, js.TemplateHead, js.TemplateMiddle, js.TemplateTail))
	var ret = make([]Token, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Token))
	}
	return ret
}

func (n TemplateLiteral) Substitution() []Expression {
	nodes := n.Children(selector.Expression)
	var ret = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expression))
	}
	return ret
}

type This struct {
	*Node
}

type ThisType struct {
	*Node
}

type ThrowStatement struct {
	*Node
}

func (n ThrowStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type TryStatement struct {
	*Node
}

func (n TryStatement) Block() Block {
	return Block{n.Child(selector.Block)}
}

func (n TryStatement) Catch() (Catch, bool) {
	field := Catch{n.Child(selector.Catch)}
	return field, field.IsValid()
}

func (n TryStatement) Finally() (Finally, bool) {
	field := Finally{n.Child(selector.Finally)}
	return field, field.IsValid()
}

type TsAmbientBinding struct {
	*Node
}

func (n TsAmbientBinding) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsAmbientBinding) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n TsAmbientBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type TsAmbientClass struct {
	*Node
}

func (n TsAmbientClass) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientClass) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsAmbientClass) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsAmbientClass) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()
}

func (n TsAmbientClass) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()
}

func (n TsAmbientClass) TsAmbientClassBody() TsAmbientClassBody {
	return TsAmbientClassBody{n.Child(selector.TsAmbientClassBody)}
}

type TsAmbientClassBody struct {
	*Node
}

func (n TsAmbientClassBody) TsAmbientClassElement() []TsAmbientClassElement {
	nodes := n.Children(selector.TsAmbientClassElement)
	var ret = make([]TsAmbientClassElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsAmbientClassElement))
	}
	return ret
}

type TsAmbientEnum struct {
	*Node
}

func (n TsAmbientEnum) TsEnum() TsEnum {
	return TsEnum{n.Child(selector.TsEnum)}
}

type TsAmbientFunction struct {
	*Node
}

func (n TsAmbientFunction) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsAmbientFunction) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsAmbientFunction) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n TsAmbientFunction) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type TsAmbientFunctionMember struct {
	*Node
}

func (n TsAmbientFunctionMember) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientFunctionMember) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n TsAmbientFunctionMember) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsAmbientFunctionMember) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n TsAmbientFunctionMember) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type TsAmbientImportAlias struct {
	*Node
}

func (n TsAmbientImportAlias) TsImportAliasDeclaration() TsImportAliasDeclaration {
	return TsImportAliasDeclaration{n.Child(selector.TsImportAliasDeclaration)}
}

type TsAmbientIndexMember struct {
	*Node
}

func (n TsAmbientIndexMember) IndexSignature() IndexSignature {
	return IndexSignature{n.Child(selector.IndexSignature)}
}

type TsAmbientInterface struct {
	*Node
}

func (n TsAmbientInterface) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientInterface) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsAmbientInterface) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsAmbientInterface) TsInterfaceExtends() (TsInterfaceExtends, bool) {
	field := TsInterfaceExtends{n.Child(selector.TsInterfaceExtends)}
	return field, field.IsValid()
}

func (n TsAmbientInterface) ObjectType() ObjectType {
	return ObjectType{n.Child(selector.ObjectType)}
}

type TsAmbientModule struct {
	*Node
}

func (n TsAmbientModule) BindingIdentifier() []BindingIdentifier {
	nodes := n.Children(selector.BindingIdentifier)
	var ret = make([]BindingIdentifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, BindingIdentifier{node})
	}
	return ret
}

func (n TsAmbientModule) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type TsAmbientNamespace struct {
	*Node
}

func (n TsAmbientNamespace) BindingIdentifier() []BindingIdentifier {
	nodes := n.Children(selector.BindingIdentifier)
	var ret = make([]BindingIdentifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, BindingIdentifier{node})
	}
	return ret
}

func (n TsAmbientNamespace) TsAmbientElement() []TsAmbientElement {
	nodes := n.Children(selector.TsAmbientElement)
	var ret = make([]TsAmbientElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsAmbientElement))
	}
	return ret
}

type TsAmbientPropertyMember struct {
	*Node
}

func (n TsAmbientPropertyMember) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientPropertyMember) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n TsAmbientPropertyMember) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type TsAmbientTypeAlias struct {
	*Node
}

func (n TsAmbientTypeAlias) TypeAliasDeclaration() TypeAliasDeclaration {
	return TypeAliasDeclaration{n.Child(selector.TypeAliasDeclaration)}
}

type TsAmbientVar struct {
	*Node
}

func (n TsAmbientVar) TsAmbientBinding() []TsAmbientBinding {
	nodes := n.Children(selector.TsAmbientBinding)
	var ret = make([]TsAmbientBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsAmbientBinding{node})
	}
	return ret
}

type TsAsExpression struct {
	*Node
}

func (n TsAsExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n TsAsExpression) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TsCastExpression struct {
	*Node
}

func (n TsCastExpression) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n TsCastExpression) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type TsConditional struct {
	*Node
}

func (n TsConditional) Check() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n TsConditional) Ext() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType)).(TsType)
}

func (n TsConditional) Truet() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType).Next(selector.TsType)).(TsType)
}

func (n TsConditional) Falset() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType).Next(selector.TsType).Next(selector.TsType)).(TsType)
}

type TsDynamicImport struct {
	*Node
}

func (n TsDynamicImport) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type TsEnum struct {
	*Node
}

func (n TsEnum) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsEnum) TsEnumBody() TsEnumBody {
	return TsEnumBody{n.Child(selector.TsEnumBody)}
}

type TsEnumBody struct {
	*Node
}

func (n TsEnumBody) TsEnumMember() []TsEnumMember {
	nodes := n.Children(selector.TsEnumMember)
	var ret = make([]TsEnumMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsEnumMember{node})
	}
	return ret
}

type TsEnumMember struct {
	*Node
}

func (n TsEnumMember) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n TsEnumMember) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}

type TsExclToken struct {
	*Node
}

type TsExportAssignment struct {
	*Node
}

func (n TsExportAssignment) IdentifierReference() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

type TsImplementsClause struct {
	*Node
}

func (n TsImplementsClause) TypeReference() []TypeReference {
	nodes := n.Children(selector.TypeReference)
	var ret = make([]TypeReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeReference{node})
	}
	return ret
}

type TsImportAliasDeclaration struct {
	*Node
}

func (n TsImportAliasDeclaration) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsImportAliasDeclaration) Ref() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var ret = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, IdentifierReference{node})
	}
	return ret
}

type TsImportRequireDeclaration struct {
	*Node
}

func (n TsImportRequireDeclaration) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type TsIndexMemberDeclaration struct {
	*Node
}

func (n TsIndexMemberDeclaration) IndexSignature() IndexSignature {
	return IndexSignature{n.Child(selector.IndexSignature)}
}

type TsInterface struct {
	*Node
}

func (n TsInterface) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsInterface) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsInterface) TsInterfaceExtends() (TsInterfaceExtends, bool) {
	field := TsInterfaceExtends{n.Child(selector.TsInterfaceExtends)}
	return field, field.IsValid()
}

func (n TsInterface) ObjectType() ObjectType {
	return ObjectType{n.Child(selector.ObjectType)}
}

type TsInterfaceExtends struct {
	*Node
}

func (n TsInterfaceExtends) TypeReference() []TypeReference {
	nodes := n.Children(selector.TypeReference)
	var ret = make([]TypeReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeReference{node})
	}
	return ret
}

type TsNamespace struct {
	*Node
}

func (n TsNamespace) BindingIdentifier() []BindingIdentifier {
	nodes := n.Children(selector.BindingIdentifier)
	var ret = make([]BindingIdentifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, BindingIdentifier{node})
	}
	return ret
}

func (n TsNamespace) TsNamespaceBody() TsNamespaceBody {
	return TsNamespaceBody{n.Child(selector.TsNamespaceBody)}
}

type TsNamespaceBody struct {
	*Node
}

func (n TsNamespaceBody) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type TsNamespaceExportDeclaration struct {
	*Node
}

func (n TsNamespaceExportDeclaration) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type TsNonNull struct {
	*Node
}

func (n TsNonNull) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type TsThisParameter struct {
	*Node
}

func (n TsThisParameter) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type TupleType struct {
	*Node
}

func (n TupleType) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type TypeAliasDeclaration struct {
	*Node
}

func (n TypeAliasDeclaration) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TypeAliasDeclaration) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TypeAliasDeclaration) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeAnnotation struct {
	*Node
}

func (n TypeAnnotation) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeArguments struct {
	*Node
}

func (n TypeArguments) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type TypeConstraint struct {
	*Node
}

func (n TypeConstraint) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeName struct {
	*Node
}

func (n TypeName) Ref() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var ret = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, IdentifierReference{node})
	}
	return ret
}

type TypeParameter struct {
	*Node
}

func (n TypeParameter) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TypeParameter) TypeConstraint() (TypeConstraint, bool) {
	field := TypeConstraint{n.Child(selector.TypeConstraint)}
	return field, field.IsValid()
}

func (n TypeParameter) TsType() (TsType, bool) {
	field := ToJsNode(n.Child(selector.TsType)).(TsType)
	return field, field.JsNode() != nil
}

type TypeParameters struct {
	*Node
}

func (n TypeParameters) TypeParameter() []TypeParameter {
	nodes := n.Children(selector.TypeParameter)
	var ret = make([]TypeParameter, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeParameter{node})
	}
	return ret
}

type TypePredicate struct {
	*Node
}

func (n TypePredicate) Paramref() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

func (n TypePredicate) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeQuery struct {
	*Node
}

func (n TypeQuery) IdentifierReference() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var ret = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, IdentifierReference{node})
	}
	return ret
}

type TypeReference struct {
	*Node
}

func (n TypeReference) TypeName() TypeName {
	return TypeName{n.Child(selector.TypeName)}
}

func (n TypeReference) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

type TypeVar struct {
	*Node
}

type UnaryExpression struct {
	*Node
}

func (n UnaryExpression) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type UnionType struct {
	*Node
}

func (n UnionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type UniqueType struct {
	*Node
}

func (n UniqueType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type VariableDeclaration struct {
	*Node
}

func (n VariableDeclaration) BindingIdentifier() (BindingIdentifier, bool) {
	field := BindingIdentifier{n.Child(selector.BindingIdentifier)}
	return field, field.IsValid()
}

func (n VariableDeclaration) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n VariableDeclaration) TsExclToken() (TsExclToken, bool) {
	field := TsExclToken{n.Child(selector.TsExclToken)}
	return field, field.IsValid()
}

func (n VariableDeclaration) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n VariableDeclaration) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type VariableStatement struct {
	*Node
}

func (n VariableStatement) VariableDeclaration() []VariableDeclaration {
	nodes := n.Children(selector.VariableDeclaration)
	var ret = make([]VariableDeclaration, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, VariableDeclaration{node})
	}
	return ret
}

type WhileStatement struct {
	*Node
}

func (n WhileStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n WhileStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type WithStatement struct {
	*Node
}

func (n WithStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n WithStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type Yield struct {
	*Node
}

func (n Yield) Expression() (Expression, bool) {
	field := ToJsNode(n.Child(selector.Expression)).(Expression)
	return field, field.JsNode() != nil
}
